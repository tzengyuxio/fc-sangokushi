# MEMORY.md — 三國志 NES ROM 逆向工程研究記錄

## ROM 概要

| 項目 | 值 |
|------|------|
| 檔名 | `Sangokushi__Japan_.nes` |
| Mapper | 1 (MMC1) |
| PRG ROM | 256 KB = 16 banks × 16 KB |
| PRG 偏移 | 0x00010 – 0x4000F (扣除 16-byte iNES header) |
| CHR ROM | 0 KB (CHR-RAM, tile 資料存於 PRG ROM) |
| Bank 換算 | 檔案偏移 = bank × 0x4000 + 0x10 |

---

## 武將資料表 (已完成解析)

### 位置
- 所在 Bank: 14 (檔案偏移 0x38010–0x3C00F)
- 表頭: 0x38010–0x38013 = `4C 00 00 00` (0x4C = 76)
- 資料起始: 0x38014
- 記錄數: 256 筆
- 資料結束: 0x39113

### 記錄結構 (17 bytes/筆)

```
Offset  Size  欄位             說明
+0      1     Age (signed)     年齡, signed byte. 正=遊戲開始時年齡, 負=尚未出生
+1      1     Body             體力 (15–100), 推測為壽命/健康度
+2      1     Intelligence     智力 (15–100) ✓已驗證
+3      1     Military         武力 (15–100) ✓已驗證
+4      1     Charisma         魅力 (15–100) ✓已驗證
+5      1     Luck             運氣? (15–100), 用途未確認
+6      1     Loyalty          忠誠 (12–100), 君主固定100
+7      1     Status+Navy      複合 bitfield:
                                 bit0 = 水軍旗標 (1=水軍) ✓已驗證
                                 bit1 = 統領旗標 (1=君主或軍師)
                                 組合: 0=一般非水軍, 1=一般水軍,
                                       2=統領非水軍(軍師), 3=統領水軍(君主)
+8,+9   2     Troops (LE16)    兵士數, little-endian ✓已驗證
+10     1     City             城市 ID (0–55), 0=未配置
+11     1     Faction          勢力 ID (0–14), 0=無勢力
+12–16  5     Separator        固定 0A 0A 0A 00 00
```

### 統計
- 水軍 151 人 / 非水軍 105 人
- 統領 15 人 (12 君主 + 3 軍師)
- 負年齡 (未出生) 12 人

### 勢力對照 (推斷)
| Faction | 勢力 | 起始記錄 |
|---------|------|----------|
| 1 | 曹操 | #0, #1 |
| 2 | 孫堅 | #2 |
| 3 | 劉備 | #3 |
| 4 | 袁紹 | #4 |
| 5 | 袁術 | #5 |
| 6 | 劉表 | #6 |
| 7 | 董卓 | #7 |
| 8 | 劉焉 | #8 |
| 9 | 馬騰 | #9 |
| 10 | 公孫瓚 | #10 |
| 11 | 陶謙 | #141 |
| 12–14 | 其他 | — |

### 未確認欄位
- **B1 (Body)**: 範圍 15–100, 推測壽命或健康度, 需要更多遊戲驗證
- **B5 (Luck)**: 範圍 15–100, 可能是運氣/義理, 需要更多遊戲驗證
- **B0 (Age)**: 確認為年齡, 但表頭的 0x4C=76 意義不明 (可能為初始可用武將數?)

### 分隔符分析 (+12–16, 5 bytes)

**觀察結果:**
- 所有 256 筆武將記錄的分隔符都是 `0A 0A 0A 00 00`，完全相同
- ROM 中只有一個 17-byte 記錄表結構（武將資料表本身）
- 未發現其他平行的舞台配置表

**假設檢驗: 5 bytes 對應 5 個遊戲舞台?**
- 遊戲有 5 個舞台，武將在不同舞台可能有不同狀態（未登場/已登場/死亡）
- 若此假設成立，每個武將應該有不同的值，但實際上所有記錄都相同
- **結論: 此假設不成立**

**可能的解釋:**
1. 這 5 bytes 確實只是結構標記/填充，用於記錄對齊或結束標記
2. 舞台配置資料存在 RAM 而非 ROM（遊戲啟動時根據選擇的舞台動態設定）
3. 舞台差異資料使用不同結構儲存在 ROM 其他位置（如差分資料）

**補充統計:**
- 城市=0 且 勢力=0 的武將: 75 人（可能為在野或尚未登場）
- 這些武將的登場狀態可能由遊戲程式根據舞台動態決定

---

## 武將姓名對照 (已完成)

透過外部資料「光榮三國志系列武將登場統計 - 能力表.csv」的 S01 欄位，以五項能力值 (體力/智力/武力/魅力/運勢) 進行比對，成功匹配 **255/256** 筆武將姓名。

匹配方式: ROM 記錄的 (Body, Intelligence, Military, Charisma, Luck) 與外部 CSV 的 S01 能力值完全一致。

| 項目 | 數量 |
|------|------|
| 總記錄數 | 256 |
| 成功匹配 | 255 |
| 未匹配 | 1 (Index 0, 能力值 88/90/91/97/90, 可能為自訂君主) |

詳細對照請參考匯出的 CSV/XLSX 檔案。

---

## 武將姓名表 (已完成解析)

### 位置
- 所在 Bank: 14 (與武將資料表同 Bank)
- 表頭: 0x3A310–0x3A313 = `4C 00 00 00` (與武將資料表相同)
- 資料起始: 0x3A314
- 記錄數: 257 筆 (包含索引 0 的新君主模板)
- 資料結束: 約 0x3B824

### 記錄結構 (15 bytes/筆)

```
Offset  Size  欄位             說明
+0      8     Name             假名 (半角片假名, Shift-JIS 0xA6–0xDF)
                               以 0x00 結尾，不足 8 bytes 則填充 0x00
+8      1     Kanji1 TileID    第一個漢字的 tile ID ✓已驗證
+9      1     Kanji1 Page      漢字 Page 指示器 (0=Page0, 1=Page1)
+10     1     Kanji2 TileID    第二個漢字的 tile ID ✓已驗證
+11     1     Kanji2 Page      漢字 Page 指示器
+12     1     Kanji3 TileID    第三個漢字的 tile ID ✓已驗證 (複姓用)
+13     1     Kanji3 Page      漢字 Page 指示器
+14     1     Portrait         頭像索引 byte (portrait = byte - 1) ✓已驗證
```

**漢字 tile ID 說明:**
- 每個武將姓名最多 3 個漢字 (位於 +8, +10, +12)
- Tile ID 對應遊戲內 CHR-RAM 中的漢字圖形
- 共發現 238 個不同的漢字 tile ID
- 詳細對照表見下方「漢字 Tile 對照表」章節

### 編碼說明

假名使用 **Shift-JIS 半角片假名** 編碼 (0xA6–0xDF):
- 清音: ｱ(0xB1) ｲ(0xB2) ｳ(0xB3) ｴ(0xB4) ｵ(0xB5) ...
- 濁音: 基本假名 + ﾞ(0xDE), 如 ｶﾞ = 0xB6 0xDE
- 半濁音: 基本假名 + ﾟ(0xDF), 如 ﾊﾟ = 0xCA 0xDF
- 拗音: 小字 ｬ(0xAC) ｭ(0xAD) ｮ(0xAE) ｯ(0xAF)

### 比對結果

| 索引 | ROM 假名 | 對應漢字 |
|------|----------|----------|
| 0 | ｿｳｿｳ | (新君主模板?) |
| 1 | ｿｳｿｳ | 曹操 |
| 2 | ｿﾝｹﾝ | 孫堅 |
| 3 | ﾘｭｳﾋﾞ | 劉備 |
| 4 | ｴﾝｼｮｳ | 袁紹 |
| 5 | ｴﾝｼﾞｭﾂ | 袁術 |
| 6 | ﾘｭｳﾋｮｳ | 劉表 |
| 7 | ﾄｳﾀｸ | 董卓 |
| 8 | ﾘｭｳｴﾝ | 劉焉 |
| 9 | ﾊﾞﾄｳ | 馬騰 |
| 10 | ｺｳｿﾝｻﾝ | 公孫瓚 |
| ... | ... | ... |

與外部 CSV 比對成功率: **249/257** (96.9%)

---

## 假名字體 tile (已定位)

### 位置
- 所在 Bank: 8 (檔案偏移 0x20010–0x24010)
- 字體起始: 0x22CA0
- Tile 大小: 8×8 pixels, 16 bytes/tile

### 字體特徵
- 每個假名 tile 包含陰影效果 (上半部分淡色, 下半部分深色)
- 可能用於遊戲中的人名顯示

### 五十音對照表 (推測)
從 0x22CA0 開始，tile 按五十音順序排列:
```
Tile  0 = ア   Tile 10 = サ   Tile 20 = ナ   Tile 30 = マ   Tile 40 = ラ
Tile  1 = イ   Tile 11 = シ   Tile 21 = ニ   Tile 31 = ミ   Tile 41 = リ
Tile  2 = ウ   Tile 12 = ス   Tile 22 = ヌ   Tile 32 = ム   Tile 42 = ル
Tile  3 = エ   Tile 13 = セ   Tile 23 = ネ   Tile 33 = メ   Tile 43 = レ
Tile  4 = オ   Tile 14 = ソ   Tile 24 = ノ   Tile 34 = モ   Tile 44 = ロ
Tile  5 = カ   Tile 15 = タ   Tile 25 = ハ   Tile 35 = ヤ   Tile 45 = ワ
Tile  6 = キ   Tile 16 = チ   Tile 26 = ヒ   Tile 36 = ユ   Tile 46 = ヲ
Tile  7 = ク   Tile 17 = ツ   Tile 27 = フ   Tile 37 = ヨ   Tile 47 = ン
Tile  8 = ケ   Tile 18 = テ   Tile 28 = ヘ   Tile 38 = ...
Tile  9 = コ   Tile 19 = ト   Tile 29 = ホ   Tile 39 = ...
```

濁點 (゛) 和半濁點 (゜) 可能在 tile 45 之後。

---

## 漢字 Tile 對照表 (已完成解析)

### 圖形儲存位置 (已確認)

透過 Mesen debugger 追蹤，確認漢字 tile 圖形的 ROM 位置：

```
PRG_ROM_offset = 0x205E4 + (tile_id + 0x30) × 16
File_offset = PRG_ROM_offset + 0x10
```

- **基址 (PRG ROM)**: `0x205E4`
- **基址 (檔案)**: `0x205F4`
- **所在 Bank**: 8 (0x20010–0x2400F)
- **每個漢字**: 64 bytes (4 個 8×8 tiles)
- **PPU 偏移**: `+0x30` (tile_id + 0x30 = PPU tile index)

### 統計
- Page 0: **241** 個不同的漢字 tile ID (0x01-0xFF)
- Page 1: **67** 個擴展漢字 (0x01-0x42, 需 +9/+11/+13 flag)
- 總計: **308** 個漢字

### 部分對照表 (依 tile ID 排序)

```
ID   漢字    ID   漢字    ID   漢字    ID   漢字    ID   漢字
0x01 翊     0x10 王     0x24 關     0x3E 堅     0x55 司
0x02 苞     0x11 黃     0x25 韓     0x3F 憲     0x5A 慈
0x03 允     0x12 樊     0x26 玩     0x40 權     0x6E 諸
0x04 紘     0x13 稠     0x27 雍     0x41 謙     0x6F 徐
0x05 羽     0x14 軫     0x28 曠     0x43 嚴     0x8D 操
0x06 熙     0x15 夏     0x29 翔     0x44 玄     0x8E 曹
0x07 叡     0x16 華     0x2A 紀     0x45 胡     0x91 孫
0x08 蔡     0x17 旻     0x2B 儀     0x46 顧     0x92 遜
0x09 永     0x18 陶     0x2C 宜     0x47 吳     0x9F 張
0x0A 琦     0x19 璋     0x2D 休     0x4A 公     0xA0 超
0x0B 琮     0x1A 沛     0x2E 宮     0x4B 孔     0xA1 陳
0x0C 越     0x1B 郭     0x2F 玠     0x4C 洪     0xAB 董
0x0D 延     0x1C 懿     0x30 許     0x4D 晃     0xB6 馬
0x0E 應     0x1D 龐     0x31 顗     0x50 高     0xBD 備
0x0F 汜     0x1E 桓     0x32 興     0x51 綱     0xE3 劉
0x10 王     0x1F 于     0x33 欽     0x52 濟     0xE5 亮
...
```

### 驗證範例

| 索引 | 假名 | Tile IDs (hex) | 解碼漢字 | 外部比對 |
|------|------|----------------|----------|----------|
| 1 | ｿｳｿｳ | 8E 8D | 曹操 | ✓ |
| 2 | ｿﾝｹﾝ | 91 3E | 孫堅 | ✓ |
| 3 | ﾘｭｳﾋﾞ | E3 BD | 劉備 | ✓ |
| 174 | ｼｮｶﾂﾘｮｳ | 6E E5 | 諸亮 | ✓ (諸葛亮，葛字可能省略) |

完整對照表定義於 `sangokushi_extract_v2.py` 的 `KANJI_TILE_MAP` 常數中。

---

## 頭像系統 (已完成)

### 概要
- 總共 **81** 個主要頭像 (獨立 tile 資料)
- 每個頭像 = 6×6 tiles = 48×48 pixels
- Tile 資料存放於 PRG ROM Banks 4-6
- 256 個武將共用這些頭像 (多人共用同一頭像)

### 頭像指標表

**位置**: `0x1BC38` (81 entries × 4 bytes = 324 bytes)

每筆記錄結構:
```
Offset  Size  欄位
+0      1     Bank          資料所在 bank (4-6)
+1      1     TileCount     tile 數量 (28-36)
+2      2     Address       bank 內位址 (little-endian, $8xxx)
```

檔案偏移計算: `file_offset = bank × 0x4000 + (addr - 0x8000) + 0x10`

### 武將→頭像映射 (已解決)

**位置**: 姓名表每筆記錄的 byte 14

```
portrait_index = name_record[+14] - 1
```

範圍: 0-80 (共 81 個頭像)

### Tile 排列系統

頭像分為兩類:

**1. 36-tile 標準頭像 (32 個)**
- 索引: 6, 7, 8, 24, 25, 26, 29, 35, 38, 40, 41, 43, 44, 45, 46, 47, 49, 51, 58, 59, 61, 66, 68, 69, 70, 72, 74, 75, 76, 77, 79, 80
- 使用標準 2×2 metatile 排列 (STANDARD_LAYOUT):
```
[ 1  2][ 5  6][ 9 10]
[ 3  4][ 7  8][11 12]
[13 14][17 18][21 22]
[15 16][19 20][23 24]
[25 26][29 30][33 34]
[27 28][31 32][35 36]
```

**2. <36-tile 頭像 (49 個)**
- tile 數量: 28-35 (重複利用 tile 以節省空間)
- 使用排列表指定各位置的 tile 編號

### 排列表

**位置**: `0x1B0D4` (81 entries × 36 bytes = 2,916 bytes)

每筆排列是 36 bytes，對應 6×6 的 tile 位置。
- 值為 PPU tile index (0x64-0x87)
- 轉換為 ROM tile 編號: `rom_tile = ppu_value - 0x63`

### 頭像→排列映射 (已解決)

**公式**: `arrangement_index = portrait_index` (1:1 對應)

排列表正好 81 個條目，與頭像數量完全相同。
36-tile 標準頭像使用 STANDARD_LAYOUT，其他頭像直接用索引查找排列表。

### 驗證範例

| 武將 | 頭像索引 | 排列索引 |
|------|----------|----------|
| 劉備 | 0 | 0 |
| 諸葛亮 | 1 | 1 |
| 關羽 | 2 | 2 |
| 曹操 | 4 | 4 |
| 孫堅 | 20 | 20 |
| 袁紹 | 44 | STD |

### NES Tile 格式
- 每個 tile: 8×8 pixels, 16 bytes
- 2 bitplanes, 每個 8 bytes
- 像素值 = plane0_bit + (plane1_bit << 1)

### 色盤
```
Index 0: (0, 0, 0)         黑色
Index 1: (247, 216, 165)   淺膚色
Index 2: (234, 158, 34)    深膚色
Index 3: (255, 255, 255)   白色
```

### 匯出工具
- **portrait_export.py**: 匯出所有 81 個頭像
- 輸出: `kanji_output/portraits/portrait_XX.png`
- 總覽: `kanji_output/portrait_atlas.png`

---

## 大眾臉頭像系統 (P81+)

### 概要

標準頭像 (P00-P80) 有專屬的指標表與排列表，大眾臉頭像 (P81+) 使用「多組共用基底 + 可替換組件」的系統。

| 項目 | 標準頭像 | 大眾臉頭像 |
|------|----------|----------|
| 索引範圍 | 0-80 (81 個) | 81-254 (174 個) |
| 指標表 | 0x1BC38 | 未找到 (可能由程式碼計算) |
| 排列表 | 0x1B0D4 | 0x1ED14 (20 條) |
| Tile 資料 | Banks 4-6 | Bank 7 (多個基底位址) |
| 結構 | 完整獨立頭像 | 多組共用基底 + 可變臉部組件 |

### 框架 Group 系統 (已完整解析)

大眾臉頭像使用 **19 個 Group** (框架 tile 組) 配合 **8 種 Pattern** (tile 排列模式) 的組合系統。

#### 19 個 Group 位置表

Group 邊界由 **內容區塊** 決定，以全黑 (blank) tiles 為分隔符：

| Group | ROM 基底 | Tiles | 備註 |
|-------|----------|-------|------|
| G00 | 0x1C194 | 24 | 舊編號 B |
| G01 | 0x1C314 | 24 | |
| G02 | 0x1C494 | 24 | |
| G03 | 0x1C614 | 24 | |
| G04 | 0x1C794 | 22 | |
| G05 | 0x1C914 | 21 | 舊編號 C |
| G06 | 0x1CA94 | 20 | 注意: 跳過前一個 blank tile |
| G07 | 0x1CC14 | 20 | |
| G08 | 0x1CD94 | 21 | |
| G09 | 0x1CF14 | 24 | |
| G10 | 0x1D094 | 21 | |
| G11 | 0x1D214 | 21 | |
| G12 | 0x1D394 | 22 | 舊編號 E |
| G13 | 0x1D514 | 22 | |
| G14 | 0x1D694 | 24 | 舊編號 A (標準參考) |
| G15 | 0x1D814 | 24 | |
| G16 | 0x1D994 | 24 | |
| G17 | 0x1DB14 | 24 | 舊編號 D |
| G18 | 0x1DC94 | 24 | |

**總計**: 430 內容 tiles + 26 blank 分隔 tiles = 456 tiles

#### 8 種 Pattern 定義

| Pattern | 最大 Tile | 特徵 | 使用 Group |
|---------|-----------|------|------------|
| P1 | 23 | 標準 24-tile 排列 | G00-G03, G09, G14-G18 |
| P2 | 22 | tile 12 重複 | G04 |
| P3 | 20 | tile 13 重複 | G05, G08, G10 |
| P4 | 20 | tile 12 重複 | G06 |
| P5 | 19 | tile 0 重複 (左邊緣) | G07 |
| P6 | 20 | tile 0 重複 | G11 |
| P7 | 21 | tile 13 重複 | G12 |
| P8 | 21 | tile 12 重複 | G13 |

#### 排列模板 (Template) 儲存位置

**ROM 位址**: `0x1ED14`
**結構**: 20 條記錄 × 36 bytes = 720 bytes
**編碼**: 固定 tiles 使用 `value - 0x64`，變體位置標記為 `0x00`

| Template | ROM 位址 | Pattern |
|----------|----------|---------|
| T00 | 0x1ED14 | P1 |
| T01 | 0x1ED38 | P1 |
| T02 | 0x1ED5C | P1 |
| T03 | 0x1ED80 | P1 |
| T04 | 0x1EDA4 | P1 (未使用) |
| T05 | 0x1EDC8 | P2 |
| T06 | 0x1EDEC | P3 |
| T07 | 0x1EE10 | P4 |
| T08 | 0x1EE34 | P5 |
| T09 | 0x1EE58 | P3 |
| T10 | 0x1EE7C | P1 |
| T11 | 0x1EEA0 | P3 |
| T12 | 0x1EEC4 | P6 |
| T13 | 0x1EEE8 | P7 |
| T14 | 0x1EF0C | P8 |
| T15 | 0x1EF30 | P1 |
| T16 | 0x1EF54 | P1 |
| T17 | 0x1EF78 | P1 |
| T18 | 0x1EF9C | P1 |
| T19 | 0x1EFC0 | P1 |

#### Group → Template → Pattern 完整對應表

**映射規則**:
- G00-G03: 使用 T00-T03 (直接對應)
- G04-G18: 使用 T05-T19 (跳過 T04，offset +1)

⚠️ **T04 未被使用**！ROM 有 20 個 Template，但只有 19 個 Group。

```python
# Group → Template 映射
GROUP_TO_TEMPLATE = {
    0: 0, 1: 1, 2: 2, 3: 3,    # G00-G03 直接對應
    4: 5, 5: 6, 6: 7, 7: 8,    # G04-G07 跳過 T04
    8: 9, 9: 10, 10: 11,       # G08-G10
    11: 12, 12: 13, 13: 14,    # G11-G13
    14: 15, 15: 16, 16: 17, 17: 18, 18: 19,  # G14-G18
}

# Group → Pattern (透過 Template)
GROUP_TO_PATTERN = {
    0: 1, 1: 1, 2: 1, 3: 1,   # G00-G03 → P1 (標準)
    4: 2,                      # G04 → P2
    5: 3,                      # G05 → P3
    6: 4,                      # G06 → P4
    7: 5,                      # G07 → P5
    8: 3,                      # G08 → P3
    9: 1,                      # G09 → P1
    10: 3,                     # G10 → P3
    11: 6,                     # G11 → P6
    12: 7,                     # G12 → P7
    13: 8,                     # G13 → P8
    14: 1, 15: 1, 16: 1, 17: 1, 18: 1,  # G14-G18 → P1 (標準)
}
```

#### 關鍵發現

1. **Group 邊界不固定**: 不是每個 Group 都有 24 tiles，範圍 20-24 tiles
2. **Blank tiles 是分隔符**: 全黑 tiles 標記 Group 邊界，不屬於任何 Group
3. **G06 特殊**: 起始位址 0x1CA94 (非 0x1CA84)，前一個 blank tile 是分隔符
4. **Pattern 決定 tile 重用**: 較少 tiles 的 Group 透過 Pattern 重複使用特定 tiles
5. **T04 未使用**: ROM 有 20 個 Template 但只有 19 個 Group，T04 (0x1EDA4) 是多餘的
6. **G04+ 有 offset**: G04 開始使用 T05，Group 編號與 Template 編號差 1

### 已驗證的 Group 成員 (2026-02-27 更新)

| Group | 基底位址 | 已知成員 |
|-------|----------|----------|
| G00 | 0x1C194 | P083 孫瑜 |
| G05 | 0x1C914 | P131 法正, P165 張昭, P166 張紘 |
| G07 | 0x1CC14 | P204 韓玄, P211 鞏志 |
| G12 | 0x1D394 | P168 虞翻 |
| G14 | 0x1D694 | P081 周泰, P082 孫翊, P084 孫桓 |
| G16 | 0x1D994 | P186 周倉 |
| G17 | 0x1DB14 | P182 糜芳, P195 徐盛 |
| G18 | 0x1DC94 | P185 傅士仁 |

**重要發現: Group C 內有多種框架 tile 組**

Group C 內存在至少兩種不同的框架 tile 組:

| 框架類型 | Tile 範圍 | 特徵 | 成員 |
|----------|-----------|------|------|
| 標準型 | 0-23 | 2×2 metatile 模式 | P131 法正, P165 張昭, P166 張紘 |
| 左邊緣重複型 | 48-67 | Row 0-5 的 C0 使用 48 重複 | P204 韓玄, P211 鞏志 |

**關鍵發現：Group B 的基底比 Group A 早 336 tiles (0x1500 bytes)**

ROM 空間佈局（以 Group B 基底 0x1C194 為參考）:
```
0x1C194: Group B 基底 (tile 0)
         ├─ tiles 0-23: Group B 共用框架
         ├─ ...
         ├─ tiles 462-464: P083 眼睛
         ├─ tiles 519-521: P083 臉部
         ├─ tiles 588-593: P083 嘴巴
         │
0x1D694: Group A 基底 (= Group B tile 336)
         ├─ tiles 336-359: Group A 共用框架 (即 Group A 的 0-23)
         ├─ tiles 507-509: P081 眼睛 (即 Group A 的 171-173)
         ├─ tiles 570-572: P081 臉部 (即 Group A 的 234-236)
         ├─ tiles 672-677: P081 嘴巴 (即 Group A 的 336-341)
         └─ ...
```

### Group A 詳細結構 (已驗證)

#### 組件式 Layout

```
6×6 格子 Layout:
     C0  C1  C2  C3  C4  C5
    ┌───┬───┬───┬───┬───┬───┐
 R0 │ 0 │ 1 │ 4 │ 5 │ 8 │ 9 │ ← 共用 (頭盔)
    ├───┼───┼───┼───┼───┼───┤
 R1 │ 2 │ 3 │ 6 │ 7 │10 │11 │ ← 共用 (頭盔)
    ├───┼───┼───┼───┼───┼───┤
 R2 │12 │ ? │ ? │ ? │14 │15 │ ← 眼睛區 (C1-C3 可替換)
    ├───┼───┼───┼───┼───┼───┤
 R3 │13 │ ? │ ? │ ? │16 │17 │ ← 臉部區 (C1-C3 可替換)
    ├───┼───┼───┼───┼───┼───┤
 R4 │18 │ ? │ ? │ ? │20 │21 │ ← 嘴巴上 (C1-C3 可替換)
    ├───┼───┼───┼───┼───┼───┤
 R5 │19 │ ? │ ? │ ? │22 │23 │ ← 嘴巴下 (C1-C3 可替換)
    └───┴───┴───┴───┴───┴───┘
```

#### 已驗證的 Layout

**P081 周泰:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12, 171, 172, 173,  14,  15],  # 眼睛: 171-173
[ 13, 234, 235, 236,  16,  17],  # 臉部: 234-236
[ 18, 336, 337, 340,  20,  21],  # 嘴巴上: 336,337,340
[ 19, 338, 339, 341,  22,  23],  # 嘴巴下: 338,339,341
```

**P082 孫翊:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12, 174, 175, 176,  14,  15],  # 眼睛: +3
[ 13, 237, 238, 239,  16,  17],  # 臉部: +3
[ 18, 348, 349, 352,  20,  21],  # 嘴巴上: +12
[ 19, 350, 351, 353,  22,  23],  # 嘴巴下: +12
```

#### Group A 變體計算規則

在 Group A 內，相鄰頭像的變體 offset：
- **眼睛**: +3 tiles (171 → 174)
- **臉部**: +3 tiles (234 → 237)
- **嘴巴**: +12 tiles (336 → 348)

```python
# Group A 內的變體計算 (相對於 group 內的 index)
group_index = portrait_index - group_first_portrait  # P081 為 0, P082 為 1

eye_base = 171 + group_index * 3
face_base = 234 + group_index * 3
mouth_base = 336 + group_index * 12
```

#### 嘴巴 Tile 排列

嘴巴使用 6 個 tiles 排成 2×3，排列方式特殊：

```
Col 1  Col 2  Col 3
+0     +1     +4    (Row 4)
+2     +3     +5    (Row 5)
```

### Group B 詳細結構 (已驗證)

#### 基底位址
- **0x1C194** (在 Group A 之前 336 tiles)

#### 已驗證的 Layout

**P083 孫瑜:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12, 462, 463, 464,  14,  15],  # 眼睛: 462-464
[ 13, 519, 520, 521,  16,  17],  # 臉部: 519-521
[ 18, 588, 589, 592,  20,  21],  # 嘴巴上
[ 19, 590, 591, 593,  22,  23],  # 嘴巴下
```

#### Group A vs Group B 比較

| 區域 | P081 (Group A) | P083 (Group B) | 備註 |
|------|----------------|----------------|------|
| 基底 | 0x1D694 | 0x1C194 | 相差 336 tiles |
| 眼睛起始 | 171 | 462 | |
| 臉部起始 | 234 | 519 | |
| 嘴巴起始 | 336 | 588 | |
| 框架 tiles | 0-23 | 0-23 | 相同模式，不同資料 |

#### 統一 ROM 視角 (以 0x1C194 為 tile 0)

| 區域 | P083 tiles | P081 tiles (轉換後) | 差距 |
|------|------------|---------------------|------|
| 眼睛 | 462-464 | 507-509 | +45 |
| 臉部 | 519-521 | 570-572 | +51 |
| 嘴巴 | 588-593 | 672-677 | +84 |

**觀察**: P083 (Group B) 的變體 tiles 在 ROM 中位於 P081 (Group A) 變體 tiles 之前

#### 區域間距分析

| Group | 眼睛→臉部 | 臉部→嘴巴 |
|-------|----------|----------|
| Group A (P081) | 63 tiles | 102 tiles |
| Group B (P083) | 57 tiles | 69 tiles |

**結論**: 不同 Group 的變體 tile 間距不同，無法用單一公式計算所有大眾臉頭像

### 大眾臉排列表

**位置**: `0x1ED14`
**結構**: 20 條記錄 × 36 bytes
**編碼**: 固定 tiles 使用 `value - 0x64`，變體位置標記為 `0x00`

### 變體計算公式 (已驗證 - 修正版)

**關鍵發現: Group A 與 Group B 共用同一組變體 tiles！**

ROM 空間佈局:
```
0x1C194: Group B 基底 (共用框架 tiles 0-23)
         ...
0x1D694: Group A 基底 (共用框架 tiles 0-23)
         ...
0x1DE14: 變體 tiles 開始 (兩個 Group 共用)
         = Group A tile 120 = Group B tile 456
```

**變體公式:**
```
eye_tile  = 120 + eye_idx × 3   (20 組, tiles 120-179)
face_tile = 180 + face_idx × 3  (20 組, tiles 180-239)
mouth_tile = 240 + mouth_idx × 6 (20 組, tiles 240-359)
```

注意: 以上 tile 編號相對於各自的 Group 基底
- Group A: 直接使用上述編號
- Group B: 編號 + 336 (因為基底差 336 tiles)

**已驗證的索引值 (2026-02-27 更新，Group 重新編號):**

⚠️ **重要更新**: 發現 0x1C014 處有被使用的 Group framework，所有 Group 編號 +1。
現在共有 20 個 Group (G00-G19) 對應 20 個 Template (T00-T19)，1:1 映射。

| 頭像 | Group | eye_idx | face_idx | mouth_idx | 備註 |
|------|-------|---------|----------|-----------|------|
| P081 周泰 | G15 | 17 | 18 | 16 | |
| P082 孫翊 | G15 | 18 | 19 | 18 | |
| P083 孫瑜 | G01 | 2 | 1 | 2 | |
| P084 孫桓 | G15 | 18 | 15 | 15 | |
| P131 法正 | G06 | 7 | 8 | 6 | |
| P165 張昭 | G06 | 9 | 8 | 6 | |
| P166 張紘 | G06 | 9 | 8 | 8 | |
| P168 虞翻 | G13 | 13 | 10 | 10 | |
| P182 糜芳 | G18 | 15 | 15 | 15 | |
| P185 傅士仁 | G19 | 15 | 16 | 17 | |
| P186 周倉 | G17 | 19 | 17 | 19 | |
| P195 徐盛 | G18 | 16 | 19 | 18 | |
| P204 韓玄 | G08 | 5 | 5 | 5 | |
| P211 鞏志 | G08 | 5 | 6 | 8 | |
| P120 李肅 | G16 | 17 | 17 | 19 | |
| P121 李傕 | G10 | 13 | 14 | 13 | |
| P122 蔡邕 | G10 | 14 | 12 | 14 | |
| P123 郭汜 | G11 | 10 | 11 | 12 | |
| P124 張濟 | G11 | 11 | 14 | 13 | |
| P125 華雄 | G16 | 17 | 15 | 16 | |
| P127 徐榮 | G11 | 13 | 10 | 10 | |
| P128 胡軫 | G16 | 18 | 19 | 18 | |
| P129 趙岑 | G16 | 18 | 15 | 15 | |
| P130 董旻 | G11 | 14 | 13 | 11 | |
| P092 陳琳 | G05 | 8 | 6 | 7 | |
| P093 田豐 | G05 | 9 | 7 | 9 | |
| P095 沮授 | G05 | 9 | 8 | 6 | |
| P097 高覽 | G01 | 3 | 1 | 2 | |
| P099 袁譚 | G02 | 0 | 1 | 2 | |
| P100 袁熙 | G02 | 2 | 1 | 2 | |
| P111 黃祖 | G10 | 12 | 11 | 12 | |
| P117 張允 | G04 | 4 | 4 | 3 | |
| P118 蔡和 | G04 | 3 | 4 | 3 | |
| P119 蔡中 | G04 | 1 | 4 | 3 | |
| P135 鄧賢 | G06 | 8 | 6 | 7 | |
| P138 高沛 | G00 | 2 | 3 | 1 | **新發現的 G00** |
| P214 文聘 | G18 | 18 | 16 | 17 | |
| P146 馬鐵 | G02 | 1 | 0 | 0 | |
| P147 侯選 | G17 | 15 | 15 | 15 | |
| P148 程銀 | G02 | 3 | 0 | 0 | |
| P149 李堪 | G03 | 2 | 3 | 1 | 用戶輸入「李湛」|
| P150 張橫 | G17 | 15 | 16 | 17 | |
| P189 闞澤 | G07 | 7 | 7 | 7 | |

**觀察:**
- 每種組件有 20 個變體 (0-19)
- 眼睛和臉部各佔 3 tiles，嘴巴佔 6 tiles
- 同一變體可被不同頭像共用 (P082 和 P084 共用 eye_idx=18)
- Group 與變體有親和區間 (見下方)

**Group-變體親和區間 (更新後):**
| Group 區間 | 變體親和範圍 |
|------------|--------------|
| G00-G04 | #0-#4 |
| G05-G10 | #5-#9 |
| G11-G14 | #10-#14 |
| G15-G19 | #15-#19 |

**✅ T04 問題已解決 (2026-02-27):**

發現 0x1C014 處存在有效的 Group framework (24 tiles)，位於原 G00 之前。
此 Group 使用 T00，所有現有 Group 編號遞增 1，現在共 20 個 Group (G00-G19)。
P138 高沛 現在正確映射到 G00。

### Group D 詳細結構 (已驗證，編號已更新)

**基底位址:** 0x1DB14 (Group A 之後 72 tiles)

**P195 徐盛:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12,  96,  97,  98,  14,  15],  # eye_idx=16
[ 13, 165, 166, 167,  16,  17],  # face_idx=19
[ 18, 276, 277, 280,  20,  21],  # mouth_idx=18
[ 19, 278, 279, 281,  22,  23],
```

**Group D 框架特徵:** 標準框架 (與 Group A 相同)

### Group E 詳細結構 (已驗證)

**基底位址:** 0x1D394 (Group A 之前 48 tiles)

**P168 虞翻:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12, 207, 208, 209,  14,  15],  # eye_idx=13
[ 13, 258, 259, 260,  16,  17],  # face_idx=10
[ 13, 348, 349, 352,  19,  13],  # mouth_idx=10 (注意: C0=13, C4=19, C5=13)
[ 18, 350, 351, 353,  20,  21],  # (注意: C0=18)
```

**Group E 框架特徵:** Row 4-5 邊緣 tiles 略有不同

### Group A 更多範例

**P182 糜芳 (框架 72-95):**
```python
[ 72,  73,  76,  77,  80,  81],
[ 74,  75,  78,  79,  82,  83],
[ 84, 165, 166, 167,  86,  87],  # eye_idx=15
[ 85, 225, 226, 227,  88,  89],  # face_idx=15
[ 90, 330, 331, 334,  92,  93],  # mouth_idx=15
[ 91, 332, 333, 335,  94,  95],
```

**觀察:** 糜芳使用不同的框架 tile 組 (72-95)，但仍屬於 Group A

### Group C 詳細結構 (多框架型)

**基底位址:** 0x1C914

Group C 特殊之處在於包含多種框架 tile 組:

#### 框架類型 1: 標準型 (tiles 0-23)

**P131 法正:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12, 357, 358, 359,  14,  15],  # eye_idx=7
[ 13, 420, 421, 422,  16,  13],  # face_idx=8
[ 13, 492, 493, 496,  18,  13],  # mouth_idx=6
[ 17, 494, 495, 497,  19,  20],
```

**P165 張昭:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12, 363, 364, 365,  14,  15],  # eye_idx=3 (修正: 非 9)
[ 13, 420, 421, 422,  16,  13],  # face_idx=3 (修正: 非 8)
[ 13, 492, 493, 496,  18,  13],  # mouth_idx=10 (修正: 非 6)
[ 17, 494, 495, 497,  19,  20],
```

**P166 張紘:**
```python
[  0,   1,   4,   5,   8,   9],
[  2,   3,   6,   7,  10,  11],
[ 12, 363, 364, 365,  14,  15],  # eye_idx=4 (修正: 非 9)
[ 13, 423, 424, 425,  16,  13],  # face_idx=4 (修正: 非 9)
[ 13, 504, 505, 508,  18,  13],  # mouth_idx=11 (修正: 非 8)
[ 17, 506, 507, 509,  19,  20],
```

#### 框架類型 2: 左邊緣重複型 (tiles 48-67)

**P204 韓玄:**
```python
[ 48,  49,  51,  52,  55,  56],
[ 48,  50,  53,  54,  57,  58],
[ 48, 351, 352, 353,  59,  60],  # eye_idx=5
[ 48, 411, 412, 413,  61,  62],  # face_idx=5
[ 48, 486, 487, 490,  64,  65],  # mouth_idx=5
[ 63, 488, 489, 491,  66,  67],
```

**P211 鞏志:**
```python
[ 48,  49,  51,  52,  55,  56],
[ 48,  50,  53,  54,  57,  58],
[ 48, 351, 352, 353,  59,  60],  # eye_idx=5 (與韓玄相同!)
[ 48, 414, 415, 416,  61,  62],  # face_idx=6
[ 48, 504, 505, 508,  64,  65],  # mouth_idx=8
[ 63, 506, 507, 509,  66,  67],
```

**觀察:**
- 韓玄與鞏志共用相同的框架 tiles (48-67)
- 共用相同的眼睛變體 (eye_idx=5, tiles 351-353)
- 臉部和嘴巴使用不同變體

### 變體索引表 (已發現三個獨立表格)

**重大發現**: 變體索引不是以 bit-packed 方式存放，而是分散在**三個獨立的 174 字節表格**中。

#### 表格位置

| 表格 | ROM 位址 | 檔案偏移 | 大小 | 值範圍 | 可能用途 |
|------|----------|----------|------|--------|----------|
| 表 1 | $1EFE4 | 0x1EFE4 | 174 bytes | 0-4 | 選擇器/模板索引 |
| 表 2 | $1F092 | 0x1F092 | 174 bytes | 0-4 | 變體索引 A |
| 表 3 | $1F140 | 0x1F140 | 174 bytes | 0-4 | 變體索引 B |

#### 已知頭像的表格值

| 頭像 | 武將 | 表1 | 表2 | 表3 | 備註 |
|------|------|-----|-----|-----|------|
| P081 | 周泰 | 0 | 2 | 0 | Group A |
| P082 | 孫翊 | 0 | 0 | 0 | Group A |
| P083 | 孫瑜 | 0 | 1 | 3 | Group B |
| P084 | 孫桓 | 0 | 1 | 1 | Group A |
| P085 | 吳夫人 | 0 | 3 | 2 | |
| P131 | 法正 | 3 | 3 | 4 | Group C |

#### 表格結構分析

**表 1 ($1EFE4) - 前 15 條:**
```
P081: 0  P086: 3  P091: 3
P082: 0  P087: 0  P092: 0
P083: 0  P088: 0  P093: 0
P084: 0  P089: 1  P094: 2
P085: 0  P090: 2  P095: 4
```

**可能的映射關係:**
- 表 1 可能是 Group/模板選擇器 (0-4 對應不同的基底或框架)
- 表 2、表 3 可能是組件變體索引的一部分
- 三個表的值可能需要通過公式組合才能得到最終的 eye/face/mouth 索引

**待驗證:**
1. 三個表格值如何映射到 eye_idx, face_idx, mouth_idx
2. 表 1 的值是否對應 Group A-E
3. 是否存在查找表將 0-4 擴展為 0-19 範圍

### 待解決問題

1. **變體索引計算機制**: RAM 中的變體值 (01, 03, 02, 00, 03) 不是直接存在 ROM，而是動態計算的
2. **$1EFE4 索引表用途**: 174 bytes，值 0-4，可能是 Group 或模板選擇器，但與 19 個 Group 的對應關係待確認
3. **命令流 $E9AD 的完整解析**: 組件載入的命令序列如何產生變體參數
4. **Tile 繪製階段 ($0C=$24)**: 36 次迴圈如何排列 6×6 tiles
5. **portrait_id → Group 映射**: 174 個大眾臉頭像 (P081-P254) 如何對應到 19 個 Group

### 已確認的關鍵發現

1. **分流點 $F699**: `CMP $0C` 比較 portrait_index 與 $42 (66)，區分標準/大眾臉頭像
2. **三階段處理流程**:
   - 第一階段：頭像類型判斷
   - 第二階段：組件載入（5 次迴圈，$08=0-4）
   - 第三階段：Tile 繪製（36 次迴圈，$08=0-35）
3. **命令流切換**: 大眾臉頭像切換到 $E9AD 命令序列
4. **RAM $04EA-$04FF 是內部堆疊**: 由 $02-$03 指標管理，不是直接索引表
5. **變體參數編碼在命令流中**: 小數值 (0-4) 直接出現在命令流 bytes 中，如 $E9B2=02, $EB5A=02
6. **命令碼複合編碼**: 部分命令碼的低 4 位作為參數傳遞（AND #$0F 提取）

### 下次繼續方向

1. **比較不同頭像的命令流**: 檢查 P082、P131 等的命令流是否有不同的變體參數
2. **$1EFE4 選擇器如何決定命令流**: 選擇器值 0-4 如何映射到不同的命令流位址
3. **Tile 繪製階段追蹤**: 觀察 36 次迴圈如何排列 6×6 tiles
4. **$D51B 命令流分析**: 這是另一個 callstack 來源，可能處理不同組件

### 已解決問題

1. ~~其他 Group 基底~~: 已確認 19 個 Group (G00-G18) 的精確 ROM 位址
2. ~~portrait_matcher 工具~~: 可自動從遊戲截圖識別 layout 和變體索引
3. ~~Group → Pattern 映射~~: 已確認 19 個 Group 對應到 8 種 Pattern 的完整對照表
4. ~~Group 邊界問題~~: 確認以 blank tiles 為分隔符，Group 大小 20-24 tiles 不等
5. ~~Template 儲存與對應~~: 20 個 Template 於 0x1ED14，G00-G03 直接對應 T00-T03，G04+ 跳過 T04 使用 T05+

### 調試進度 (進行中)

**目標**: 找出 portrait_index 如何轉換為頭像 tile 資料的程式邏輯

#### 重大發現：頭像分流邏輯

**關鍵斷點: $F699** - 這是區分標準頭像與組合頭像的分流點

```asm
F697  LDA $08        ; A = portrait_index (例: $52 = 82)
F699  CMP $0C        ; 與 $0C 比較 ($0C = $42 = 66)
F69B  LDA $09        ; 16-bit 比較的高位部分
F69D  SBC $0D
...
F6A9  STA $08        ; 結果: 0 (>= 66) 或 1 (< 66)
F6AB  JMP $F0A7      ; 回到命令分派器
```

**分流邏輯:**
| 條件 | 結果 ($08) | 跳轉路徑 | 說明 |
|------|-----------|----------|------|
| portrait < 66 ($42) | 1 | $F40B | 標準武將頭像 |
| portrait >= 66 ($42) | 0 | $F3FB | 大眾臉/特殊頭像 |

**注意**: 分界點是 **$42 (66)**，不是 $51 (81)。這表示:
- 0-65: 標準武將頭像
- 66-80: 特殊角色頭像 (非武將)
- 81+: 大眾臉組合頭像

#### 條件分支程式碼

```asm
; $F411 - 根據比較結果分支
F411  LDA $08        ; 載入比較結果
F413  ORA $09
F415  BEQ $F3FB      ; 結果 = 0 → 跳到大眾臉頭像處理
F417  BNE $F40B      ; 結果 ≠ 0 → 跳到標準頭像處理

; $F3FB - 大眾臉頭像路徑 (portrait >= 66)
F3FB  JSR $F7FF      ; 讀取新命令流位址
F3FE  STA $06        ; 設定命令流指標 (低位)
F400  STX $07        ; 設定命令流指標 (高位)
F402  JMP $F0A7      ; 用新命令流繼續執行

; $F40B - 標準頭像路徑 (portrait < 66)
F40B  JSR $F7FF
F40E  JMP $F0A7
```

**關鍵差異**: 大眾臉頭像會**切換命令流指標**到新的位址 (例: $EB85)

#### 命令分派器 ($F0A7)

遊戲使用 bytecode 命令解釋器處理頭像繪製:

```asm
F0A7  LDY #$00
F0A9  LDA ($06),Y    ; 從命令流讀取命令碼
F0AB  INC $06        ; 遞增命令流指標
...
F0B1  TAX
F0B2  LDA $F866,X    ; 查表: 處理函數位址低位
F0B5  STA $00
F0B7  LDA $F966,X    ; 查表: 處理函數位址高位
F0BA  STA $01
F0BC  JMP ($0000)    ; 跳到處理函數
```

#### 已追蹤的執行流程 (周泰 P081)

1. 姓名表讀取: portrait byte $52 從 PRG ROM $3A55B 讀取
2. 複製到 RAM: 存入 $0527
3. 載入處理: 從 $0527 讀取，存入 $08
4. 比較分流: $F699 處與 $42 比較，結果 = 0 (因為 $52 >= $42)
5. 切換命令流: $F3FB 切換到命令流 $EB85
6. PPU 寫入: 最終透過 $C4CA 寫入 PPU

#### PPU 寫入點

```asm
C4CA  STA $2007      ; 寫入 PPU 資料
```
- 資料來源指標: $5C-$5D (指向 RAM $0504)
- 頭像 tiles 寫入 PPU Pattern Table $1880+ (Tile #392+)

#### 待解決

1. **大眾臉頭像的命令流 $EB85 的完整解析**: 了解如何從 portrait_index 計算出 Group 和變體索引
2. **標準頭像的處理路徑 $F40B**: 如何查詢指標表 $1BC38
3. **ROM 資料表存取點**: 找到讀取 $1EFD4 (選擇器) 或 $1ED14 (排列模板) 的程式碼

#### 調試用斷點清單

| 位址 | 類型 | 用途 |
|------|------|------|
| $F699 | Execute | **關鍵** - 頭像分流比較點 |
| $F3FB | Execute | 大眾臉頭像路徑入口 |
| $F40B | Execute | 標準頭像路徑入口 |
| $F0A7 | Execute | 命令分派器入口 |
| $C4CA | Execute | PPU 寫入點 |
| $3A55B | PRG ROM Read | 周泰 portrait byte 讀取 |

#### 組件載入迴圈（第二階段詳細分析）

頭像繪製分為三個階段：

**第一階段：頭像類型判斷**
- $0C = $42 (66), $08 = portrait_index
- 比較結果決定標準/大眾臉頭像路徑

**第二階段：組件載入（5 次迴圈）**
```
迴圈 | $0C | $08 | 行為
-----|-----|-----|------
  0  | $04 |  0  | 讀取位址 $E9AD 但丟棄（跳過）
  1  | $04 |  1  | 切換命令流到 $E9AD，開始載入
  2  | $04 |  2  | 載入下一組件
  3  | $04 |  3  | 載入下一組件
  4  | $04 |  4  | 載入下一組件
```

**第三階段：Tile 繪製（36 次迴圈）**
- $0C = $24 (36), $08 = 0-35
- 繪製 6×6 = 36 個 tiles 到 PPU

#### 組件載入命令序列（$E9AD 開始）

從命令流 $E9AD 追蹤到的命令處理：

| 命令碼 | 處理函數 | 功能 |
|--------|----------|------|
| $D7 | $F405 | 條件分支：$08=0 跳過，$08>0 切換命令流 |
| $AD | $F32D | 從 RAM 表讀取值到 $08 |
| $8C | $F308 | 讀取 16-bit 值，設定 $0C-$0D |
| $BB | $F5E1 | 16-bit 加法：$08-$09 += $0C-$0D |

#### RAM 參數表（$04E0-$04FF）

頭像繪製時，相關參數存放在 RAM $04E0 區域：

```
04E0: 04 BD E9 00 BD E9 00 00 3E 00 10 00 00 00 01 F3
04F0: F7 04 2A 05 AD F3 FD 04 2A 05 9F EB 00 9F EB 10
```

- $04E1-$04E2: $E9BD（位址指標）
- $04EE: $01（被讀取的參數值）
- $04FA-$04FB: $EB9F（位址指標）

#### 關鍵子程式

| 位址 | 功能 |
|------|------|
| $F7FF | 從命令流讀取 16-bit 位址，返回 A=低位, X=高位 |
| $F82C | 計算 $00-$01 = 命令流偏移 + $04-$05（基底） |
| $F848 | 堆疊 push 操作 |
| $F330 | 從 RAM 讀取組件參數：`LDA ($00),Y` → `STA $08` |

#### F330 讀取追蹤（周泰 P081，迭代 $08=4）

F330 會在每次迭代中**觸發多次**，從不同 RAM 位址讀取參數：

| 觸發次序 | RAM 位址 | 讀取值 | 備註 |
|----------|----------|--------|------|
| 1 | $7FB1 | $01 | 不同區域 |
| 2-6 | $04FF | $10 | 重複 5 次 |
| 7 | $04ED | $00 | |
| 8 | $04EE | $03 | Tiles 開始出現 |
| 9 | $04EC | $02 | |
| 10 | $04EE | $03 | |
| 11 | $04EB | $03 | |
| 12 | $04EE | $03 | |
| 13 | $04EA | $01 | |
| 14 | $04ED | $00 | 所有 Tiles 載入完成 |
| 15-16 | $04EE | $03, $00 | |

#### RAM $04EA-$04FF 參數結構

頭像載入時，這塊 RAM 包含關鍵參數：

```
$04EA = $01  ← 可能的組件索引
$04EB = $03
$04EC = $02
$04ED = $00
$04EE = $03
$04EF = ?
$04FF = $10 (16)
```

**重要發現**：這些值（01, 03, 02, 00, 03）**不是直接存在 ROM 中**，而是動態計算或從命令流解析出來的。

#### ROM 索引表結構 ($1EFE4)

**位置**: $1EFE4（檔案偏移 0x1EFE4）
**大小**: 174 bytes（對應 174 個大眾臉頭像 P081-P254）
**值範圍**: 0-4

```
P081: $00    P086: $03    P091: $03    P096: $01
P082: $00    P087: $00    P092: $00    P097: $00
P083: $00    P088: $00    P093: $00    P098: $01
P084: $00    P089: $01    P094: $02    P099: $04
P085: $00    P090: $02    P095: $04    P100: $03
```

這可能是 **Group 選擇器**或**排列模板索引**，但與我們定義的 Group A-E 不完全對應。

#### ROM $1EFD4 區域結構

$1EFD4-$1EFE3（$1EFE4 之前的 16 bytes）包含較大的值：

```
+00: 00 00 74 75
+04: 76 00 00 00
+08: 78 79 77 00
+12: 00 00 7A 7B
```

值 74-7B（十進位 116-123）可能是排列模板指標或 tile 索引。

#### 排列模板 ($1ED14)

**位置**: $1ED14
**結構**: 20 條記錄 × 36 bytes

前幾條模板開頭相同：
```
模板 0: 64 65 68 69 6C 6D 66 67 6A 6B 6E 6F...
模板 1: 64 65 68 69 6C 6D 66 67 6A 6B 6E 6F...
...
```

值 $64 = 框架 tile 0（64 - 64 = 0），這與我們之前的發現一致。

#### 命令流中的變體參數（重大發現）

**變體參數直接編碼在命令流中**，不是從單獨的表格查詢！

**命令流 $E9AD**（檔案偏移 0x3E9AD）：
```
$E9AD: 7F 6A E9 CC D4 [02] CF 20 63 F0 F6 FF 40 D6 C2 E9
                      ↑
                   變體參數 02
$E9CD: [04] A0 FA FF D0 A2 FA FF ...
       ↑
    變體參數 04
```

**命令流 $EB51**（檔案偏移 0x3EB61）：
```
$EB50: CF 20 63 F0 D9 FF 3C E9 12 D6 [02] 2B 61 DE FD FF
          ↑                          ↑
       JSR $F063                  變體參數 02
```

**發現的小數值 (0-4) 位置**：
| 命令流位址 | 檔案偏移 | 值 |
|------------|----------|-----|
| $E9B2 | 0x3E9B2 | 02 |
| $E9CD | 0x3E9CD | 04 |
| $EB5A | 0x3EB6A | 02 |

#### 堆疊操作 ($F848)

$F848 是 bytecode 解釋器的**堆疊 push 子程式**：

```asm
F848  TAY            ; 暫存 A
F849  SEC
F84A  LDA $02        ; $02-$03 是堆疊指標
F84C  SBC #$02       ; 堆疊指標 -2
F84E  STA $02
...
F857  STA ($02),Y    ; 存 A 到堆疊
F85B  STA ($02),Y    ; 存 X 到堆疊
F85D  JMP $F0A7      ; 回到命令分派器
```

**RAM $04EA-$04FF 是內部堆疊區域**，不是直接的索引表。
堆疊指標 $02-$03 指向當前堆疊頂端。

#### F848 觸發記錄（周泰 P081）

| 順序 | A | X | Callstack |
|------|---|---|-----------|
| 1 | 00 | 00 | $EB51 |
| 2 | 10 | 00 | $EB51 |
| 3 | 08 | 00 | $EB51 |
| 4 | 08 | 00 | $EB51 |
| 5 | **03** | 00 | $EB51 |
| 6 | 00 | 00 | $D51B |
| 7 | 10 | 00 | $D51B |
| 8 | 08 | 00 | $D51B |
| 9 | 0B | 00 | $D51B |
| 10 | **03** | 00 | $D51B |
| 11 | 00 | 00 | $D51B |
| 12 | 0D | 00 | $D51B |
| 13 | **03** | **05** | $EB51 |
| 14 | 10 | 00 | $EB51 |

值 $03 出現多次，與 RAM 中觀察到的 $03 相符。

#### 命令碼低位元提取 ($F258)

部分命令處理使用 `AND #$0F` 提取命令碼低 4 位作為參數：

```asm
F258  TXA            ; A = 命令碼 (如 $60)
F259  AND #$0F       ; A = 低 4 位 (如 $00)
F25B  LDX #$00
F25D  JMP $F848      ; push 到堆疊
```

這表示命令碼可能是**複合編碼**：
- 高 4 位：命令類型
- 低 4 位：參數值 (0-15)

#### 已嘗試但效果有限的方法

1. 監視 $5C 或 $0504 的寫入 - 太頻繁，被其他程式使用
2. PRG ROM Read Breakpoint 在 $1EFC4 - 未觸發
3. ROM 搜尋 `E9 51` (SBC #$51) - 找到 10 處，但關鍵比較是與 $42 非 $51

### 工具

**tools/portrait_matcher.py** - 自動匹配截圖與 ROM tiles

```bash
# 使用方法
python tools/portrait_matcher.py <screenshot.png> <group> [--portrait-id PXXX]

# 範例
python tools/portrait_matcher.py mob_portrait/screenshot/法正.png C --portrait-id P131
```

支援的 Groups:
- A (0x1D694), B (0x1C194), C (0x1C914), D (0x1DB14)
- E (0x1D394), F (0x1D994), G (0x1DC94), H (0x102A4)

### 輸出檔案

**Group 框架分析 (mob_portrait/all_tiles/):**
- `_group_00.png` ~ `_group_18.png`: 各 Group 框架圖 (使用對應 Pattern 排列)
- `_all_groups.png`: 19 個 Group 總覽 (5×4 排列)
- `_group_pattern_matrix_v4.png`: Group × Pattern 完整對照矩陣
- `_20_groups.html`: 分析報告 (含 ROM 位址表)
- `_analysis.html`: 系統架構分析報告

**Group A (0x1D694 = G14):**
- `mob_portrait/tiles/layout_P81_P82.txt`: P081, P082 的完整 layout
- `mob_portrait/tiles/zhou_tai_portrait.png`: P081 周泰頭像
- `mob_portrait/tiles/sun_yi_portrait_corrected.png`: P082 孫翊頭像

**Group B (0x1C194 = G00):**
- `mob_portrait/tiles_P083/layout_P083.txt`: P083 layout 與分析
- `mob_portrait/tiles_P083/sun_yu_portrait.png`: P083 孫瑜頭像
- `mob_portrait/tiles_P083/tile_000.png ~ tile_799.png`: 800 個 tiles
- `mob_portrait/tiles_P083/_sheet_0_799.png`: 合併圖表

**截圖:**
- `mob_portrait/screenshot/`: 遊戲截圖 (用於 portrait_matcher.py)

**探索用:**
- `mob_portrait/tiles_negative/`: 負向 tile 探索 (用於尋找其他 Group)

---

## 檔案清單

| 檔案 | 說明 |
|------|------|
| `sangokushi_extract_v2.py` | 武將資料解析主程式 (含頭像/排列索引) |
| `kanji_export.py` | 漢字字型匯出工具 |
| `portrait_export.py` | 頭像匯出工具 (48×48 PNG) |
| `Sangokushi (Japan)_characters_v2.csv` | 匯出的 CSV (256 筆武將) |
| `Sangokushi (Japan)_characters_v2.xlsx` | 匯出的 Excel (含格式, 需 openpyxl) |
| `光榮三國志系列武將登場統計 - 能力表.csv` | 外部參考資料, 用於比對武將姓名 |
| `CLAUDE.md` | Claude Code 專案指示 |
| `MEMORY.md` | 本檔案 — 研究記錄 |
| `docs/DATA_FORMAT.md` | 武將資料表格式 (含頭像映射) |
| `docs/ROM_STRUCTURE.md` | ROM 檔案結構 (含頭像系統) |
| `docs/KANJI_TILES_ANALYSIS.md` | 漢字 tile 映射分析 |
| `docs/KANJI_DIFF.md` | ROM 漢字與外部姓名差異對照 |

---

## 下一步待辦

1. ~~**頭像匯出**: 追蹤遊戲 6502 程式碼中頭像顯示流程, 建立 portrait index → tile data 的完整映射, 匯出 48×48 頭像圖片~~ ✓ 已完成
2. **城市名稱表**: 尋找 ROM 中城市 ID → 城市名稱的對照表
3. ~~**武將姓名表**: 尋找 ROM 中武將姓名的存放位置~~ ✓ 已找到 (0x3A314, 半角片假名編碼)
4. **未確認欄位**: 透過遊戲測試確認 B1 (Body) 和 B5 (Luck) 的實際用途
5. ~~**完善角色對照**: 補齊更多角色的序號-姓名-假名對應~~ ✓ 已透過外部 CSV 完成 255/256 筆
6. **舞台配置資料**: 若需確認不同舞台的武將配置，可用模擬器調試功能追蹤遊戲選擇舞台時的記憶體變化
7. ~~**姓名表未知欄位**: 解析姓名記錄中 +8 到 +14 的 7 bytes 用途~~ ✓ 已確認完整結構:
   - +8/+10/+12: 漢字 tile ID (建立 238 字對照表)
   - +9/+11/+13: 漢字 Page 指示器
   - +14: 頭像索引 byte
8. ~~**頭像與武將對應**: 找出頭像索引 (0-80) 與武將索引 (0-255) 的對應關係~~ ✓ 已解決 (姓名表 byte 14)
9. ~~**頭像→排列映射**: 建立頭像索引到排列索引的映射~~ ✓ 已解決 (1:1 對應，排列表起始 0x1B0D4)
10. **portrait_id → Group 映射**: 找出 174 個大眾臉頭像 (P081-P254) 如何對應到 19 個 Group
11. **親和區間功能**: 待親和區間規則更明確後，改進探索器：
    - 隨機時排除不協調的組合
    - 選定 Group 後只列出協調的變體
    - 或以顏色標示協調/不協調
